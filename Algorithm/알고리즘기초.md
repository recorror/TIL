# IM을 따기 위해 공부할 부분.



- **2차원 배열**

- **델타를 이용한 2차원 배열 탐색**

- **전치 행렬**
  
  - ```python
    a = [[1,2,3],[4,5,6],[7,8,9]]
    print(a) # [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
    b = list(zip(*a))
    # zip = 전치행렬
    print(b) # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
    ```

- **부분집합**
  
  - **원소가 n개일 때 공집합을 포함한 부분집합의 수는 2^n개이다.**
  
  - n번째의 수가 나올 때와 나오지 않을 때 2가지가 있다.
  
  - 즉 2가지 2가지 2가지를 계속 곱해주는 경우의 수이기 때문에 2^n개.

- **bit 연산자 <2진수로 계산하겠다 선언>**
  
  - 부분집합을 만들어주기 위해 다중 for문을 돌리는데 원소의 개수가 들어나면 for문도 똑같이 늘어나기 때문에.
  
  - 즉, 원소의 개수가 유동적이라면 다중 for문으로는 식을 써줄 수 없다. (비효율적)
    
    
  
  - 비트 연산자 &, |, <<, >> 4 각각 and, or, 피연산자의 비트 열을 왼쪽, 비트 열을 호른쪽으로 이동. 

- << 연산자
  
  - 1 << n : 2^n 즉, 원소가 n개일 경우의 모든 부분집합의 수를 의미.

- & 연산자
  
  - i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사.

                - 2진법으로 생각하면 쉬움.





- 배열 예제 : 9386 9489
